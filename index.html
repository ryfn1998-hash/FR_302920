<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TITAN PLASMA - OVERLOAD</title>
    <style>
        :root { --neon: #bc13fe; --glow: #ff00ff; }
        * { margin: 0; padding: 0; box-sizing: border-box; overflow: hidden; touch-action: none; user-select: none; }
        body { background-color: #000; height: 100vh; width: 100vw; }

        /* 邊框強化：光暈加寬、速度加倍 */
        body::after {
            content: ''; position: fixed; inset: 0; border: 10px solid transparent;
            border-image: conic-gradient(from var(--angle), transparent, var(--neon), #fff, var(--glow), transparent) 1;
            z-index: 100; pointer-events: none;
            filter: drop-shadow(0 0 35px var(--neon)) blur(1px);
            animation: rotateGradient 0.8s linear infinite;
        }

        @property --angle { syntax: '<angle>'; initial-value: 0deg; inherits: false; }
        @keyframes rotateGradient { to { --angle: 360deg; } }

        canvas { position: fixed; top: 0; left: 0; z-index: 1; transform: translateZ(0); }

        /* 毀滅性震動效果 */
        .shake { animation: heavyShake 0.2s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes heavyShake {
            0% { transform: translate(0,0); }
            20% { transform: translate(-10px, 8px); }
            40% { transform: translate(10px, -8px); }
            60% { transform: translate(-10px, -5px); }
            80% { transform: translate(10px, 5px); }
            100% { transform: translate(0,0); }
        }
    </style>
</head>
<body id="body">
    <canvas id="stage"></canvas>

    <script>
        const canvas = document.getElementById('stage');
        const ctx = canvas.getContext('2d');
        const body = document.getElementById('body');
        
        let width, height;
        let particles = [];
        let shockwaves = [];
        let touchPoints = [];

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        class Shockwave {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.r = 0;
                this.alpha = 1;
            }
            update() { this.r += 15; this.alpha -= 0.03; }
            draw() {
                ctx.save();
                ctx.strokeStyle = `rgba(188, 19, 254, ${this.alpha})`;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, isSuper = false) {
                this.x = x; this.y = y;
                this.lastX = x; this.lastY = y;
                const angle = Math.random() * Math.PI * 2;
                const force = isSuper ? Math.random() * 30 + 10 : Math.random() * 8 + 2;
                this.vx = Math.cos(angle) * force;
                this.vy = Math.sin(angle) * force;
                this.size = Math.random() * 3 + 1;
                this.color = Math.random() > 0.3 ? '#bc13fe' : '#ffffff';
                this.alpha = 1;
                this.decay = Math.random() * 0.02 + 0.01;
            }

            update() {
                this.lastX = this.x;
                this.lastY = this.y;
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.92;
                this.vy *= 0.92;
                this.alpha -= this.decay;
            }

            draw() {
                // 流光效果：連接上一幀的位置
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.size;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(this.lastX, this.lastY);
                ctx.lineTo(this.x, this.y);
                ctx.stroke();
                ctx.restore();
            }
        }

        function triggerEpic(x, y) {
            body.classList.remove('shake');
            void body.offsetWidth;
            body.classList.add('shake');

            shockwaves.push(new Shockwave(x, y));
            for (let i = 0; i < 100; i++) {
                particles.push(new Particle(x, y, true));
            }
        }

        window.addEventListener('mousedown', (e) => triggerEpic(e.clientX, e.clientY));
        window.addEventListener('touchstart', (e) => {
            e.preventDefault();
            triggerEpic(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        function animate() {
            // 背景殘影
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, width, height);
            
            ctx.globalCompositeOperation = 'lighter';

            // 繪製衝擊波
            shockwaves = shockwaves.filter(s => s.alpha > 0);
            shockwaves.forEach(s => { s.update(); s.draw(); });

            // 繪製粒子連線 (電弧感)
            ctx.lineWidth = 0.5;
            for (let i = 0; i < particles.length; i += 4) {
                for (let j = i + 1; j < particles.length; j += 15) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    if (dx*dx + dy*dy < 8000) {
                        ctx.strokeStyle = `rgba(255, 255, 255, ${particles[i].alpha * 0.2})`;
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
            }

            particles = particles.filter(p => p.alpha > 0);
            particles.forEach(p => { p.update(); p.draw(); });

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
